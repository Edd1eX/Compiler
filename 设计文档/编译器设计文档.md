## 编译器设计文档

### 一、词法分析

#### 1.编码前设计

​	对于词法分析，我设计将整个模块分为三个部分——输入、处理、输出。对于输入输出，我计划使用流来完成。对于处理部分，我打算针对特殊符号先使用`switch-case`处理，然后针对数字直接处理，最后最对字符串，只要依次与每个关键字比对，即可知道该字符串属于哪种类别。最后，遇到注释只需要跳过即可。

​	对于数据的存储，我打算使用一个类`word`来存储`单词的名称`与`单词的类别码`。

#### 2.编码时优化与问题解决

​	在编码过程时，我遇到了以下问题，并针对这些问题做了一些解决方案。

##### (1).数据大小不确定

​	针对不确定的数据大小，可能难以确定数组的大小。所以我使用了`vector`数据结构替代数组，便可解决这个问题。对于单个字符串，我使用`string`来存储。

##### (2).手误拼错单词

​	为了避免由于手误造成的结果错误，我使用字符串变量来存储每个单词，例如：

```cpp
const string IDENFR = "IDENFR";
const string INTCON = "INTCON";
......
```

这样如果拼错单词，代码便会无法通过编译，尽可能避免了错误。同时，这样做还可以进行代码补全，比较方便。

##### (3).针对字符串比对的优化

​	起初我打算使用`strcmp()`函数，使获得字符串与每个关键字比对，但是这样写起来十分麻烦，同时扩展性较差。所以我最后采用了`map`数据结构存储关键字与类别码，最后只需要判断map中**该key值是否存在**即可知道该字符串是否为关键字。例子如下：

```cpp
vector <word> lexical;
map<string,string> keyword = {{"return", RETURNTK},
                              {"main", MAINTK},
                              {"const", CONSTTK}};

void judge(string s){
		if (keyword.count(s) > 0) {
        word w(s, keyword[s]);
        lexical.push_back(w);
    }
    else {
        word w(s, IDENFR);
        lexical.push_back(w);
    }
}
```

#### 3.编码后修改

​	由于发现后续错误处理中需要记录行号，所以我设置了一个行数记录变量`line`，在每次遇到换行时进行`line++`，并在`word`类中增加`line`属性，存储该单词所在行数。

### 二、语法分析

#### 1.编码前设计

 我将词法分析的结果存在一个`vector`中，并把它传入语法分析，作为语法分析的基础。对于每一个非终结符，我都构造了一个分析器，对这个终结符单独分析。对于几个表达式文法，由于是左递归文法，需要将该文法改写，例如`LOrExp → LAndExp | LOrExp '||' LAndExp`需要改写为`LOrExp → LAndExp {'||' LAndExp }`。对于first集有交集的文法，需要考虑其follow集，并加以预判。最后，在每个分析程序结束后，都要额外输出该类型，来满足题目需求。

#### 2.编码时优化与问题解决

##### (1).CompUnit first集有交集

对于以下代码：

```cpp
int a;
int b()
{
}
int main()
{
}
```

Decl、FuncDef、MainFuncDef三个非终结符有first集交集`int`，所以要考虑follow集。对于Decl和FuncDef，如果第`now+2`个字符是`(`，那就是FuncDef，否则是Decl；对于FuncDef和MainFuncDef，如果第`now+1`个字符是`main`，则为MainFuncDef，否则是FuncDef。

对于其他文法中类似情况，一样可以用这个方法解决。

##### (2).Stmt中LVal和Exp交集问题

对于文法：

```cpp
Stmt → LVal '=' Exp ';'
  | [Exp] ';'
```

由于Exp中包含Lval，所以很难直接区分这两个文法。我使用了预读的方法，先假设进入的是LVal，然后得到LVal分析结束后读到的下一个字符。因为前者下一个字符一定是`=`，所以只需要判断这个字符是否为等号即可区分。如果不是`=`，还需要将字符回退到进入分析程序时的字符。

##### (3).改写文法造成的变化

由于之前对所有表达式文法进行了改写，之前需要调用多次自己程序，现在只需要调用一次，这造成了缺少了一部分输出。所以需要在每次进入文法的大括号部分时增加一次输出。

#### 3.编码后修改

由于之前的设计是直接输出结果，并未存储到语法树中，所以我选择了重构，构造一棵语法树，方便之后的任务。对于每个节点，我使用了`syntax`类进行定义:

```cpp
class syntax {
public:
    string s;						//单词
    string category;		//类型
    int line;						//行号
    /*
     * flag:
     * 0  —— 终结符
     * 1  —— 非终结符
     * -1 —— error
     */
    int flag;
    string syn_type;		//文法类型
    vector<syntax> child;	//子节点

  	// 构造方法
    syntax(word w);
    syntax(string syn_type);
    syntax(int error);

    void insert(syntax c);	// 插入子节点
    bool iserror();
};
```

在语法分析时，可以据此构造一棵树。最后，通过后序遍历语法树即可输出正确结果。

### 三、错误处理