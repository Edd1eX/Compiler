## 编译器设计文档

### 四、代码生成

#### 1.编码前设计

​	为了实现一个pcode编译器，我需要设计两部分内容——指令生成和指令解释，所以我将他们分开处理。指令生成部分，我将原有的语法分析得到的语法树输入，根据不同的结构生成不同的指令，存在一个vector中，并将结果交给指令解释部分处理。指令解释部分，我构造了一个栈式处理器，用来处理指令所需的数据。同时，我需要对所有变量进行内存管理，于是我构造了几个类，用来管理变量的赋值、取值。对于全局变量，我构造了一个类`memory`，将全局变量存在其中，并始终保存这个类，放在类`memoryStack`的底层，保证全局变量会一直被显示。而对于局部变量，也被保存在类`memory`中，但随着这些局部变量被移除，`memory`也会被清空。

最终，我设计了以下37条指令完成了我的编译器。

假设栈顶数据为`top1`，次栈顶数据为`top2`。

| 指令名 | 解释                           | 参数 x (int)        | 参数 y (string)    |
| ------ | ------------------------------ | ------------------- | ------------------ |
| push   | 入栈                           | 入栈数据            | 无                 |
| pop    | 移除栈顶                       | 无                  | 无                 |
| add    | top1+top2                      | 无                  | 无                 |
| sub    | top1-top2                      | 无                  | 无                 |
| mul    | top1*top2                      | 无                  | 无                 |
| div    | top1/top2                      | 无                  | 无                 |
| mod    | top1%top2                      | 无                  | 无                 |
| lss    | top1<top2                      | 无                  | 无                 |
| leq    | top1<=top2                     | 无                  | 无                 |
| eq     | top1==top2                     | 无                  | 无                 |
| neq    | top1!=top2                     | 无                  | 无                 |
| gt     | top1>top2                      | 无                  | 无                 |
| gte    | top1>=top2                     | 无                  | 无                 |
| read   | 读取一个数，并放到栈顶         | 无                  | 无                 |
| print  | 输出栈顶数据，或一个字符串     | 无                  | 若有，则输出字符串 |
| end    | 程序结束                       | 无                  | 无                 |
| init   | 初始化变量                     | 无                  | 变量名             |
| storei | 存入数据                       | 无                  | 变量名             |
| ldi    | 读取数据                       | 无                  | 变量名             |
| jump   | 跳转至标签                     | 无                  | 标签名             |
| jal    | 跳转至标签，并标记当前指令位置 | 无                  | 标签名             |
| copy   | 复制一份栈顶数据到栈顶         | 无                  | 无                 |
| bez    | 等于0时跳转                    | 无                  | 标签名             |
| bnz    | 不等于0时跳转                  | 无                  | 标签名             |
| jback  | 跳转回上一次标记位置           | 无                  | 无                 |
| cb     | 创建一个模块(block)            | 无                  | 无                 |
| db     | 删除一个模块                   | 无                  | 无                 |
| cnb    | 创建一个函数模块               | 无                  | 无                 |
| cnb    | 删除一个函数模块               | 无                  | 无                 |
| land   | top1 & top2                    | 无                  | 无                 |
| lor    | top1 \| top2                   | 无                  | 无                 |
| ops    | - top1                         | 无                  | 无                 |
| not    | ! top1                         | 无                  | 无                 |
| clear  | 清除栈到进入函数前状态         | 不为0时保留栈顶数据 | 无                 |
| off    | 传参时计算数组/变量初始位置    | 维数                | 变量名             |
| init2  | 使用数组指针初始化数组         | 无                  | 变量名             |
| off2   | 赋值时计算数组/变量初始位置    | 维数                | 变量名             |

#### 2.编码时优化与问题解决

​	在编码过程时，我遇到了以下问题，并针对这些问题做了一些解决方案。

##### (1).针对break、continue的指令生成

​	对于while循环，可以抽象为

```cpp
while(cond){
	...
}
...
```

转化成指令形式，可以抽象为

```c++
push cond
bnz while_end_1
while_loop_1:
...
while_end_1:
...
```

那么对于`continue`，可以转化为指令`jump while_loop_1`；而对于`break`，可以转化为指令`jump while_end_1`。

##### (2).针对if的指令生成

​	对于if，可以抽象为

```cpp
if(cond1){
	...
}
else if (cond2) {
  ...
}
else {
  ...
}
...
```

转化成指令形式，可以抽象为

```c++
push cond1
bnz if_false_1
...
jump if_end_1
if_false_1:
push cond2
bnz if_false_2
...
jump if_end_2
if_false_2:
...
if_end_1:
if_end_2:
...
```

则可以根据这个格式完成指令生成。

##### (3).针对与、或的短路设计

对于`&&`，可以简化为

```cpp
exp1 && exp2 && exp3 && .. && expn
```

若前面某个数值是0，那么他与任何一个数都为0，所以可以跳过后面的与运算。那么转化成指令形式，可以抽象为

```c++
push exp1
copy
bez and_or_1
  
push exp2
land
and_or_1:
copy
bez and_or_2
  
push exp3
land
and_or_2:
copy
bez and_or_3
  
...

push expn
land 
and_or_{n-1}:
```

对于`||`，可以简化为

```cpp
exp1 || exp2 || exp3 || .. || expn
```

若前面某个数值是1，那么他或任何一个数都为1，所以可以跳过后面的或运算。那么转化成指令形式，可以抽象为

```c++
push exp1
copy
bnz and_or_1
  
push exp2
lor
and_or_1:
copy
bnz and_or_2
  
push exp3
lor
and_or_2:
copy
bnz and_or_3
  
...

push expn
lor 
and_or_{n-1}:
```

##### (4).对于函数跳转的设计

当遇到函数时，可以通过jal指令跳转到函数，而函数结束时，或函数return时，可以使用jback回到之前位置。

##### (5).函数传参

对于每个变量，如果是数组变量，那么我会使用malloc一个空间来存储数据，然后根据计算得到的地址进行传参，如果是部分传参，那么我需要先计算数组的首地址，然后传参的时候，只需要传递数组该位置的指针即可；对于普通变量，我会存进一个变量里，传参的时候传变量的值即可。

#### 3.编码后修改

​	暂无。
