## 编译器设计文档

### 一、词法分析

#### 1.编码前设计

​	对于词法分析，我设计将整个模块分为三个部分——输入、处理、输出。对于输入输出，我计划使用流来完成。对于处理部分，我打算针对特殊符号先使用`switch-case`处理，然后针对数字直接处理，最后最对字符串，只要依次与每个关键字比对，即可知道该字符串属于哪种类别。最后，遇到注释只需要跳过即可。

​	对于数据的存储，我打算使用一个类`word`来存储`单词的名称`与`单词的类别码`。

#### 2.编码时优化与问题解决

​	在编码过程时，我遇到了以下问题，并针对这些问题做了一些解决方案。

##### (1).数据大小不确定

​	针对不确定的数据大小，可能难以确定数组的大小。所以我使用了`vector`数据结构替代数组，便可解决这个问题。对于单个字符串，我使用`string`来存储。

##### (2).手误拼错单词

​	为了避免由于手误造成的结果错误，我使用字符串变量来存储每个单词，例如：

```cpp
const string IDENFR = "IDENFR";
const string INTCON = "INTCON";
......
```

这样如果拼错单词，代码便会无法通过编译，尽可能避免了错误。同时，这样做还可以进行代码补全，比较方便。

##### (3).针对字符串比对的优化

​	起初我打算使用`strcmp()`函数，使获得字符串与每个关键字比对，但是这样写起来十分麻烦，同时扩展性较差。所以我最后采用了`map`数据结构存储关键字与类别码，最后只需要判断map中**该key值是否存在**即可知道该字符串是否为关键字。例子如下：

```cpp
vector <word> lexical;
map<string,string> keyword = {{"return", RETURNTK},
                              {"main", MAINTK},
                              {"const", CONSTTK}};

void judge(string s){
		if (keyword.count(s) > 0) {
        word w(s, keyword[s]);
        lexical.push_back(w);
    }
    else {
        word w(s, IDENFR);
        lexical.push_back(w);
    }
}
```

#### 3.编码后修改

​	由于发现后续错误处理中需要记录行号，所以我设置了一个行数记录变量`line`，在每次遇到换行时进行`line++`，并在`word`类中增加`line`属性，存储该单词所在行数。

### 二、语法分析

### 三、错误处理